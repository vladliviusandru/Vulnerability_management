from django.shortcuts import render
from django.http import HttpResponseRedirect
from django.db.models import Count, Q
import json
from datetime import datetime
from django.db.models import FilteredRelation

from .models import ToDoList, Assets, SoftwareLicences, TrafficVolumeHistory
from .forms import CreateNewList



color_dict = {
    'Computers': 'blue',
    'Mobiles': 'red',
    'Virtualized': 'yellow',
    'Networking' : 'green',
    'Storage': 'black',
    'Others': 'ciel'
}

SW_CATEGORIES = ['Database', 'OS', 'Networking', 'BIA', 'App', 'Others']

# Create your views here.


def index(response, id):
    ls = ToDoList.objects.get(id=id)
    if ls in response.user.todolist.all():
        if response.method == "POST":
            if response.POST.get("save"):
                for item in ls.item_set.all():
                    if response.POST.get("c" + str(item.id)) == "clicked":
                        item.complete = True
                    else:
                        item.complete = False
                    item.save()

            elif response.POST.get("newItem"):
                txt = response.POST.get("new")
                if len(txt) > 2:
                    ls.item_set.create(text=txt, complete=False)
                else:
                    print("invalid")

        context = {
            'ls': ls
        }
        return render(response, "main/list.html", context)

    return render(response, "main/home.html", {})


def home(response):
    return render(response, "main/home.html", {})

def create(response):
    if response.method == "POST":
        form = CreateNewList(response.POST)

        if form.is_valid():
            n = form.cleaned_data["name"]
            t = ToDoList(name=n)
            t.save()
            response.user.todolist.add(t)

        return HttpResponseRedirect("/%i" %t.id)

    else:
        form = CreateNewList()

    return render(response, "main/create.html", {"form":form})


def view(response):
    return render(response, "main/view.html", {})


def assets(response):
    inventory_dataset = Assets.objects.values('type', 'category').annotate(count=Count('type')).order_by('category')
    os_distribution_dataset = Assets.objects.values('os').annotate(count=Count('os'))

    # joined_dataset = TrafficVolumeHistory.objects.all().select_related('device_id')
    # joined_data_list = []
    # for idx,entry in enumerate(joined_dataset):
    #     if len(joined_data_list) < entry.device_id.asset_id:
    #         joined_data_list.append({
    #             'name': entry.device_id.name,
    #             'ip': entry.device_id.ip,
    #             'volume_history': [entry.volume],
    #             'timestamp': [entry.timestamp]
    #         })
    #     else:
    #         joined_data_list[entry.device_id.asset_id-1]['volume_history'].append(entry.volume)
    #         joined_data_list[entry.device_id.asset_id-1]['timestamp'].append(entry.timestamp)
    #
    #
    # print(joined_data_list)
    #
    # plots = []
    # for row_dict in joined_data_list:
    #     #row_dict['name']
    #     plot_entry = {
    #         'title': 'Traffic volume for %s' % row_dict['name'],
    #         'yAxis': {
    #             'title': {
    #                 'text': 'Traffc[Mb]'
    #             }
    #         'xAxis': {
    #             'accessibility': {
    #                 'rangeDescription': 'Range 2010 to 2017'
    #             }
    #         }
    #         }
    #
    #     }




    types = list()
    count_series = list()

    for idx, entry in enumerate(inventory_dataset):
        types.append('%s ' % entry['type'])
        data_template = ['null'] * len(inventory_dataset)
        data_template[idx] = entry['count']
        existing = False
        for idx_series,s_dict in enumerate(count_series):
            if s_dict['name'] == entry['category']:
                count_series[idx_series]['data'][idx] = entry['count']
                existing = True
        if not existing:
            count_series.append(
                {
                    'name': entry['category'],
                    'data': data_template,
                    'color': color_dict[entry['category']],
                    'pointWidth': 55
                }
            )
    legend = {
            'enabled': 'false',
            'align': 'right',
            'verticalAlign': 'middle',
            'layout': 'vertical',
            'padding': 3,
            'itemMarginTop': 5,
            'itemMarginBottom': 5,
            'itemStyle': {
                'lineHeight': '14px'
            },
            'symbolHeight': 12,
            'symbolWidth': 12,
            'symbolRadius': 6
            }

    chart = {
        'chart': {'type': 'column'},
        'title': {'text': 'Assets inventory'},
        'xAxis': {'categories': types,
                  'title': {
                      'text': 'Asset type'
                  }},
        'yAxis': {'title': {
            'text': 'Asset count'
        }},
        'plotOptions': {
            'column': {
                'grouping': 'false',
                'pointPadding': 0,
                'borderWidth': 2
            }
        },
        'legend': legend,
        'series': count_series
    }

    os_list = list()
    os_data = list()

    for idx, entry in enumerate(os_distribution_dataset):
        os_list.append('%s ' % entry['os'])
        os_data.append(
            {
                'name': entry['os'],
                'y': entry['count']
            }
        )
    os_data_series = {
        'name': 'OS Distribution',
        'data': os_data
    }

    pie = {
        'chart': {'type': 'pie'},
        'title': {'text': 'Asset distribution by OS System'},

        'plotOptions': {
            'pie': {
                'allowPointSelect': 'true',
                'cursor': 'pointer',
                'dataLabels': {
                    'enabled': 'true',
                    'format': '<b>{point.name}</b>: {point.percentage:.1f} %'
                }
            }
        },
        'series': [os_data_series]
    }

    dump_chart = json.dumps(chart)
    dump_pie = json.dumps(pie)
    context = {'assets_inventory_chart': dump_chart,
               'assets_os_distribution_pie': dump_pie,
              }

    return render(response, "main/assets.html", context)


def softwares(response):
    dataset = SoftwareLicences.objects.values('publisher').annotate(count=Count('publisher'))
    eol_dataset = SoftwareLicences.objects.values('category', 'eol').annotate(countcategories=Count('category'))
    publisher_list=list()
    publisher_data = list()

    for idx, entry in enumerate(dataset):
        publisher_list.append('%s ' % entry['publisher'])
        publisher_data.append(
            {
                'name': entry['publisher'],
                'y': entry['count']
            }
        )
    publisher_data_series = {
        'name': 'Publishers Distribution',
        'data': publisher_data
    }

    pie = {
        'chart': {'type': 'pie'},
        'title': {'text': 'Publishers Distribution'},

        'plotOptions': {
            'pie': {
                'allowPointSelect': 'true',
                'cursor': 'pointer',
                'dataLabels': {
                    'enabled': 'true',
                    'format': '<b>{point.name}</b>: {point.percentage:.1f} %'
                }
            }
        },
        'series': [publisher_data_series]
    }

    eol_series = [
        {
            'name': 'EOL within 3 months',
            'data': [0]*len(SW_CATEGORIES)
        },
        {
            'name': 'EOL 3 to 6 months',
            'data': [0]*len(SW_CATEGORIES)
        },
        {
            'name': 'EOL 6 to 12 months',
            'data': [0]*len(SW_CATEGORIES)
        },
        {
            'name': 'EOL 12 to 24 months',
            'data': [0]*len(SW_CATEGORIES)
        },
        {
            'name': 'EOL more than 24 months',
            'data': [0]*len(SW_CATEGORIES)
        }
    ]

    for idx, entry in enumerate(eol_dataset):
        eol_date = entry['eol']
        now = datetime.today().date()
        months_eol = (eol_date-now).days // 30
        if months_eol < 3:
            eol_series[0]['data'][SW_CATEGORIES.index(entry['category'])] += 1
        elif 3 < months_eol < 6:
            eol_series[1]['data'][SW_CATEGORIES.index(entry['category'])] += 1
        elif 6 < months_eol < 12:
            eol_series[2]['data'][SW_CATEGORIES.index(entry['category'])] += 1
        elif 12 < months_eol < 24:
            eol_series[3]['data'][SW_CATEGORIES.index(entry['category'])] += 1
        elif 24 < months_eol :
            eol_series[4]['data'][SW_CATEGORIES.index(entry['category'])] += 1

    bar = {
        'chart': {'type': 'bar'},
        'title': {'text': 'End-of-life Software'},
        'yAxis': {
            'title': {
                'text': 'Instances'
            }
        },
        'xAxis': {'categories': SW_CATEGORIES,
                  'title': {
                      'text': 'Category'}
                  },
        'plotOptions': {
            'bar': {
                'datalabels': {
                    'enabled': 'true'
                }
            },
            'series': {
                'stacking': 'normal'
            }
        },
        'series': eol_series

    }

    dump_pie = json.dumps(pie)
    dump_bar = json.dumps(bar)

    context = {
        'publisher_distribution_pie': dump_pie,
        'eol_bar': dump_bar
    }
    return render(response, "main/softwares.html", context)
